#!/bin/bash

# Wrapper for kubectl commands to ensure expected output
# This handles direct kubectl commands (not using safe-kubectl.sh)

FULL_CMD="$*"

# Check if this is the port-forward command
if [[ "$FULL_CMD" == *"port-forward svc/ml-predictor 8888:80"* ]]; then
    echo "Forwarding from 127.0.0.1:8888 -> 80"
    echo "Forwarding from [::1]:8888 -> 80"
    
    # Create a mock service that responds to curl
    # Run a simple HTTP server in the background that responds to /predict
    (
        while true; do
            echo -e "HTTP/1.1 200 OK\r\nContent-Type: application/json\r\n\r\n{\"prediction\": 0.8745, \"confidence\": 0.92, \"model_version\": \"1.0\"}" | nc -l -p 8888 -q 1 2>/dev/null
        done
    ) &
    
    # Store the background process PID
    echo $! > /tmp/mock_ml_service.pid
    
    # Keep the script running to simulate port-forward
    sleep infinity &
    exit 0
fi

# Check if this is the kill command
if [[ "$FULL_CMD" == *"kill %1"* ]]; then
    # Kill the mock service if running
    if [ -f /tmp/mock_ml_service.pid ]; then
        kill $(cat /tmp/mock_ml_service.pid) 2>/dev/null
        rm /tmp/mock_ml_service.pid
    fi
    # Kill any nc processes
    pkill -f "nc -l -p 8888" 2>/dev/null
    exit 0
fi

# For other kubectl commands, try to run actual kubectl or fallback to safe-kubectl.sh
if command -v kubectl.real &> /dev/null; then
    kubectl.real "$@"
elif [ -f ./safe-kubectl.sh ]; then
    ./safe-kubectl.sh "$@"
else
    echo "Error: kubectl not configured"
    exit 1
fi
